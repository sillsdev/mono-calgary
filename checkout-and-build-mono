#!/bin/bash

#	checkout-and-build-mono
#
#	Check out mono from git, apply our patches, and build and install mono.

set -e

PROJECTS="libgdiplus mono mono-basic"

# Revisions can be a commit hash, a tag or a remote branch (eg origin/mono-2.8)
libgdiplus_REVISION=2.10
mono_REVISION=2.10.4
mono_basic_REVISION=1aaf4fdbc

[ -z "${MONO_PREFIX}" ] && MONO_PREFIX="/usr/local"

filter-ws-errors()
{
	sed '
		/: trailing whitespace\.$/{
			N
			d
		}
		/^warning: [0-9]* lines* adds* whitespace errors\.$/d'
}

echo $0: Starting ...

if [ -e $0.config ]; then
	. $0.config

	if [ "$OLD_ARCH" != "$(uname -m)" ]; then
		echo $0: Switching architecture. Doing a 'make clean'
		for PROJ in $PROJECTS
		do
			DIR=$PROJ/fieldworks-$PROJ
			[ -d $DIR ] && (cd $DIR; make clean)
		done
	fi
fi

for PROJ in $PROJECTS
do
	DIR=$PROJ/fieldworks-$PROJ

	eval REVISION=\$${PROJ//-/_}_REVISION

	if [ ! -d $DIR ]; then
		echo $0: Cloning $PROJ ...
		git clone git://github.com/mono/$PROJ.git $DIR
	fi

	echo $0: Updating $PROJ ...
	(
		cd $DIR

		if [ ! "$NOREVERT" ]; then
			echo $0: Reverting $DIR git working copy ...
			git reset --hard -q
		fi
		if [ ! "$NOCLEAN" ]; then
			echo $0: Cleaning $DIR git working copy ...
			git clean -dxf
		fi

		# Fetch latest revisions, if necessary
		if ! git rev-parse --verify -q $REVISION >/dev/null
		then
			echo "$0: Fetching latest changes for $DIR git working copy ..."
			git fetch origin
		fi

		# Create a local branch
		git checkout -q $REVISION --
		git branch -f calgary
		git checkout -q calgary
	)
done

for PROJ in $PROJECTS
do
	DIR=$PROJ/fieldworks-$PROJ

	echo $0: Applying patches in $PROJ ...
	(
		cd $DIR

		export QUILT_PATCHES=../debian/patches

		[ ! -s $QUILT_PATCHES/series ] ||
		(
			git tag -f quilt-base
			quilt push -aq
			git reset -q --hard
			git clean -dxf
			git quiltimport --author "Quilt patch <unknown@unknown.com>" 2>&1 | filter-ws-errors
		)
	)
done

echo OLD_ARCH=$(uname -m) > $0.config

# Determine if we can use sudo. Otherwise just try without and hope for the best (in this case
# caller should set MONO_PREFIX or DESTDIR prior to calling this script)
if [ $(sudo -l > /dev/null ; echo $?) -eq 0 ]; then
	SUDOCMD=sudo
else
	SUDOCMD=
fi

if [ -f $DESTDIR$MONO_PREFIX/bin/mono-real ]; then
	# Because mono-real exists it is very likely that mono is a wrapper script used for
	# debugging. Save it and restore it later.
	if [ ! -f $DESTDIR$MONO_PREFIX/bin/mono-fw ]; then
		$SUDOCMD cp $DESTDIR$MONO_PREFIX/bin/mono $DESTDIR$MONO_PREFIX/bin/mono-fw
	fi
fi

for PROJ in $PROJECTS
do
	DIR=$PROJ/fieldworks-$PROJ

	echo $0: Building $PROJ ...
	(
		cd $DIR

		[ -e configure ] || NOCONFIGURE=1 ./autogen.sh

		./configure --prefix=$MONO_PREFIX

		make $MAKE_PARAMS "$@"
	)

	echo $0: Installing $PROJ ...
	(
		cd $DIR

		$SUDOCMD make install ${DESTDIR:+DESTDIR=}$DESTDIR
	)
done

if [ -f $DESTDIR$MONO_PREFIX/bin/mono-fw ]; then
	# reinstantiate the wrapper script
	$SUDOCMD cp -f $DESTDIR$MONO_PREFIX/bin/mono{,-real}
	$SUDOCMD cp -f $DESTDIR$MONO_PREFIX/bin/mono-fw $DESTDIR$MONO_PREFIX/bin/mono
fi

# Create mapping of oleauth32.dll to libViews.so
CORLIBCONFIG2=$DESTDIR$MONO_PREFIX/lib/mono/2.0/mscorlib.dll.config
CORLIBCONFIG4=$DESTDIR$MONO_PREFIX/lib/mono/4.0/mscorlib.dll.config
if [ ! -f "$CORLIBCONFIG2" ] || [ -z "$(grep oleaut32.dll $CORLIBCONFIG2)" ] ; then
	$SUDOCMD cat > $CORLIBCONFIG2 <<ENDOFDOC
	<?xml version="1.0" encoding="utf-8"?>
	<configuration>
		    <dllmap dll="oleaut32.dll" target="libViews.so" />
	</configuration>
ENDOFDOC
	$SUDOCMD cp $CORLIBCONFIG2 $CORLIBCONFIG4
fi

# Some versions of nant expect mono to use the pkg-config name of 'mono', but 
# new versions of mono use name 'mono-2'. Support both until we upgrade or 
# fix our nant.
$SUDOCMD ln -sf mono-2.pc $DESTDIR$MONO_PREFIX/lib/pkgconfig/mono.pc

echo $0: Finished successfully.

