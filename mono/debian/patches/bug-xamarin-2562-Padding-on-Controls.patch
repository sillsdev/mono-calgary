From 073d402bc9022d58a382cd90e52359aeb3b8dfd9 Mon Sep 17 00:00:00 2001
From: Eberhard Beilharz <eb1@sil.org>
Date: Thu, 12 Jan 2012 15:17:59 +0100
Subject: [PATCH] Xamarin-2562: Don't ignore padding on controls

ScrollableControl needs to use Padding for calculating DisplayRectangle
because DockPadding is calculated lazily.

When positioning text on button we have to use the internal property
PaddingClientRectangle which takes padding into account.

When drawing a CheckBox we need to consider padding when calculating
the position of the checkbox glyph and of the text.

Change-Id: I744dc6f1e332c364eb0b7c7bd2c0d24af9ca432d
---
 .../System.Windows.Forms/Control.cs                |    1 +
 .../System.Windows.Forms/ScrollableControl.cs      |   12 ++-
 .../System.Windows.Forms/ThemeWin32Classic.cs      |   91 ++++++++++----------
 .../Test/System.Windows.Forms/ControlTest.cs       |   13 +++
 .../System.Windows.Forms/ScrollableControlTest.cs  |   35 ++++++++
 5 files changed, 102 insertions(+), 50 deletions(-)

Index: fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/Control.cs
===================================================================
--- fieldworks-mono.orig/mcs/class/Managed.Windows.Forms/System.Windows.Forms/Control.cs
+++ fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/Control.cs
@@ -2450,6 +2450,7 @@
 		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
 		public virtual Rectangle DisplayRectangle {
 			get {
+				// for the control class the DisplayRectangle == ClientRectangle
 				return ClientRectangle;
 			}
 		}
Index: fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ScrollableControl.cs
===================================================================
--- fieldworks-mono.orig/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ScrollableControl.cs
+++ fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ScrollableControl.cs
@@ -515,11 +515,13 @@
 					display_rectangle = base.DisplayRectangle;
 				}
 
-				if (dock_padding != null) {
-					display_rectangle.X += dock_padding.Left;
-					display_rectangle.Y += dock_padding.Top;
-					display_rectangle.Width -= dock_padding.Left + dock_padding.Right;
-					display_rectangle.Height -= dock_padding.Top + dock_padding.Bottom;
+				// DockPadding is the same as Padding (according to documentation) but is
+				// calculated lazily, so we use Padding here instead.
+				if (Padding != Padding.Empty) {
+					display_rectangle.X += Padding.Left;
+					display_rectangle.Y += Padding.Top;
+					display_rectangle.Width -= Padding.Horizontal;
+					display_rectangle.Height -= Padding.Vertical;
 				}
 
 				return display_rectangle;
Index: fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ThemeWin32Classic.cs
===================================================================
--- fieldworks-mono.orig/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ThemeWin32Classic.cs
+++ fieldworks-mono/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ThemeWin32Classic.cs
@@ -61,6 +61,7 @@
 		const int SM_CYBORDER = 1;		
 		const int MENU_TAB_SPACE = 8;		// Pixels added to the width of an item because of a tabd
 		const int MENU_BAR_ITEMS_SPACE = 8;	// Space between menu bar items
+		const int CheckSize = 13;
 
 		#region	Principal Theme Methods
 		public ThemeWin32Classic ()
@@ -362,7 +363,7 @@
 		{
 			Image image = button.Image;
 			string text = button.Text;
-			Rectangle content_rect = button.ClientRectangle;
+			Rectangle content_rect = button.PaddingClientRectangle;
 			Size text_size = TextRenderer.MeasureTextInternal (text, button.Font, content_rect.Size, button.TextFormatFlags, button.UseCompatibleTextRendering);
 			Size image_size = image == null ? Size.Empty : image.Size;
 
@@ -950,15 +951,15 @@
 
 		public override void CalculateCheckBoxTextAndImageLayout (ButtonBase button, Point p, out Rectangle glyphArea, out Rectangle textRectangle, out Rectangle imageRectangle)
 		{
-			int check_size = 13;
-			
+			int check_size = CheckSize;
+
 			if (button is CheckBox)
-				check_size = (button as CheckBox).Appearance == Appearance.Normal ? 13 : 0;
+				check_size = (button as CheckBox).Appearance == Appearance.Normal ? check_size : 0;
 				
-			glyphArea = new Rectangle (0, 2, check_size, check_size);
+			glyphArea = new Rectangle (button.Padding.Left, button.Padding.Top, check_size, check_size);
 			
-			Rectangle content_rect = button.ClientRectangle;
-			ContentAlignment align = ContentAlignment.TopLeft;;
+			Rectangle content_rect = button.PaddingClientRectangle;
+			ContentAlignment align = ContentAlignment.TopLeft;
 			
 			if (button is CheckBox)
 				align = (button as CheckBox).CheckAlign;
@@ -967,42 +968,42 @@
 
 			switch (align) {
 				case ContentAlignment.BottomCenter:
-					glyphArea.Y = button.Height - check_size;
-					glyphArea.X = (button.Width - check_size) / 2 - 2;
+					glyphArea.Y += content_rect.Height - check_size - 2;
+					glyphArea.X += (content_rect.Width - check_size) / 2;
 					break;
 				case ContentAlignment.BottomLeft:
-					glyphArea.Y = button.Height - check_size - 2;
+					glyphArea.Y += content_rect.Height - check_size - 2;
 					content_rect.Width -= check_size;
 					content_rect.Offset (check_size, 0);
 					break;
 				case ContentAlignment.BottomRight:
-					glyphArea.Y = button.Height - check_size - 2;
-					glyphArea.X = button.Width - check_size;
+					glyphArea.Y += content_rect.Height - check_size - 2;
+					glyphArea.X += content_rect.Width - check_size;
 					content_rect.Width -= check_size;
 					break;
 				case ContentAlignment.MiddleCenter:
-					glyphArea.Y = (button.Height - check_size) / 2;
-					glyphArea.X = (button.Width - check_size) / 2;
+					glyphArea.Y += (content_rect.Height - check_size) / 2;
+					glyphArea.X += (content_rect.Width - check_size) / 2;
 					break;
 				case ContentAlignment.MiddleLeft:
-					glyphArea.Y = (button.Height - check_size) / 2;
+					glyphArea.Y += (content_rect.Height - check_size) / 2;
 					content_rect.Width -= check_size;
 					content_rect.Offset (check_size, 0);
 					break;
 				case ContentAlignment.MiddleRight:
-					glyphArea.Y = (button.Height - check_size) / 2;
-					glyphArea.X = button.Width - check_size;
+					glyphArea.Y += (content_rect.Height - check_size) / 2;
+					glyphArea.X += content_rect.Width - check_size;
 					content_rect.Width -= check_size;
 					break;
 				case ContentAlignment.TopCenter:
-					glyphArea.X = (button.Width - check_size) / 2;
+					glyphArea.X += (content_rect.Width - check_size) / 2;
 					break;
 				case ContentAlignment.TopLeft:
 					content_rect.Width -= check_size;
 					content_rect.Offset (check_size, 0);
 					break;
 				case ContentAlignment.TopRight:
-					glyphArea.X = button.Width - check_size;
+					glyphArea.X += content_rect.Width - check_size;
 					content_rect.Width -= check_size;
 					break;
 			}
@@ -1014,7 +1015,7 @@
 			
 			// Force wrapping if we aren't AutoSize and our text is too long
 			if (!button.AutoSize)
-				proposed.Width = button.Width - glyphArea.Width - 2;
+				proposed.Width = button.PaddingClientRectangle.Width - glyphArea.Width - 2;
 
 			Size text_size = TextRenderer.MeasureTextInternal (text, button.Font, proposed, button.TextFormatFlags, button.UseCompatibleTextRendering);
 			
@@ -1031,58 +1032,58 @@
 				case TextImageRelation.Overlay:
 					// Text is centered vertically, and 2 pixels to the right
 					textRectangle.X = content_rect.Left + 2;
-					textRectangle.Y = ((content_rect.Height - text_size.Height) / 2) - 1;
+					textRectangle.Y = button.PaddingClientRectangle.Top + ((content_rect.Height - text_size.Height) / 2) - 1;
 					textRectangle.Size = text_size;
 
 					// Image is dependent on ImageAlign
 					if (image == null)
 						return;
 
-					int image_x = 0;
-					int image_y = 0;
+					int image_x = button.PaddingClientRectangle.Left;
+					int image_y = button.PaddingClientRectangle.Top;
 					int image_height = image.Height;
 					int image_width = image.Width;
 
 					switch (button.ImageAlign) {
 						case System.Drawing.ContentAlignment.TopLeft:
-							image_x = 5;
-							image_y = 5;
+							image_x += 5;
+							image_y += 5;
 							break;
 						case System.Drawing.ContentAlignment.TopCenter:
-							image_x = (content_rect.Width - image_width) / 2;
-							image_y = 5;
+							image_x += (content_rect.Width - image_width) / 2;
+							image_y += 5;
 							break;
 						case System.Drawing.ContentAlignment.TopRight:
-							image_x = content_rect.Width - image_width - 5;
-							image_y = 5;
+							image_x += content_rect.Width - image_width - 5;
+							image_y += 5;
 							break;
 						case System.Drawing.ContentAlignment.MiddleLeft:
-							image_x = 5;
-							image_y = (content_rect.Height - image_height) / 2;
+							image_x += 5;
+							image_y += (content_rect.Height - image_height) / 2;
 							break;
 						case System.Drawing.ContentAlignment.MiddleCenter:
-							image_x = (content_rect.Width - image_width) / 2;
-							image_y = (content_rect.Height - image_height) / 2;
+							image_x += (content_rect.Width - image_width) / 2;
+							image_y += (content_rect.Height - image_height) / 2;
 							break;
 						case System.Drawing.ContentAlignment.MiddleRight:
-							image_x = content_rect.Width - image_width - 4;
-							image_y = (content_rect.Height - image_height) / 2;
+							image_x += content_rect.Width - image_width - 4;
+							image_y += (content_rect.Height - image_height) / 2;
 							break;
 						case System.Drawing.ContentAlignment.BottomLeft:
-							image_x = 5;
-							image_y = content_rect.Height - image_height - 4;
+							image_x += 5;
+							image_y += content_rect.Height - image_height - 4;
 							break;
 						case System.Drawing.ContentAlignment.BottomCenter:
-							image_x = (content_rect.Width - image_width) / 2;
-							image_y = content_rect.Height - image_height - 4;
+							image_x += (content_rect.Width - image_width) / 2;
+							image_y += content_rect.Height - image_height - 4;
 							break;
 						case System.Drawing.ContentAlignment.BottomRight:
-							image_x = content_rect.Width - image_width - 4;
-							image_y = content_rect.Height - image_height - 4;
+							image_x += content_rect.Width - image_width - 4;
+							image_y += content_rect.Height - image_height - 4;
 							break;
 						default:
-							image_x = 5;
-							image_y = 5;
+							image_x += 5;
+							image_y += 5;
 							break;
 					}
 
@@ -1153,7 +1154,7 @@
 			Rectangle		client_rectangle;
 			Rectangle		text_rectangle;
 			Rectangle		checkbox_rectangle;
-			int			checkmark_size=13;
+			int			checkmark_size = CheckSize;
 			int			checkmark_space = 4;
 
 			client_rectangle = checkbox.ClientRectangle;
@@ -1509,7 +1510,7 @@
 			if (ctrl.ThreeDCheckBoxes == false)
 				state |= ButtonState.Flat;
 
-			Rectangle checkbox_rect = new Rectangle (2, (item_rect.Height - 11) / 2, 13, 13);
+			Rectangle checkbox_rect = new Rectangle (2, (item_rect.Height - 11) / 2, CheckSize, CheckSize);
 			ControlPaint.DrawCheckBox (e.Graphics,
 				item_rect.X + checkbox_rect.X, item_rect.Y + checkbox_rect.Y,
 				checkbox_rect.Width, checkbox_rect.Height,
Index: fieldworks-mono/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ControlTest.cs
===================================================================
--- fieldworks-mono.orig/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ControlTest.cs
+++ fieldworks-mono/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ControlTest.cs
@@ -2948,6 +2948,19 @@
 			f.Show ();
 			f.Dispose ();
 		}
+
+		[Test]
+		public void DisplayRectangle_SamePadding ()
+		{
+			// The MSDN documentation says that for a control ClientRectangle == DisplayRectangle
+			using (var c = new Control ())
+			{
+				c.Size = new Size (100, 100);
+				c.Padding = new Padding (4);
+				Assert.AreEqual (new Rectangle (0, 0, 100, 100), c.ClientRectangle);
+				Assert.AreEqual (c.ClientRectangle, c.DisplayRectangle);
+			}
+		}
 	}
 
 	[TestFixture]
Index: fieldworks-mono/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ScrollableControlTest.cs
===================================================================
--- fieldworks-mono.orig/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ScrollableControlTest.cs
+++ fieldworks-mono/mcs/class/Managed.Windows.Forms/Test/System.Windows.Forms/ScrollableControlTest.cs
@@ -344,5 +344,40 @@
 			Assert.AreEqual (true, scrollable.VerticalScroll.Visible, "#C0");
 		}
 #endif
+
+		// Tests Xamarin-2562
+		[Test]
+		public void DisplayRectangle_SamePadding ()
+		{
+			using (var c = new ScrollableControl ())
+			{
+				c.Size = new Size (100, 100);
+				c.Padding = new Padding (4);
+				Assert.AreEqual (new Rectangle (0, 0, 100, 100), c.ClientRectangle);
+				Assert.AreEqual (new Rectangle (4, 4, 92, 92), c.DisplayRectangle);
+			}
+		}
+
+		[Test]
+		public void DisplayRectangle_DifferentPadding ()
+		{
+			using (var c = new ScrollableControl ())
+			{
+				c.Size = new Size (100, 100);
+				c.Padding = new Padding (1, 2, 3, 4);
+				Assert.AreEqual (new Rectangle (0, 0, 100, 100), c.ClientRectangle);
+				Assert.AreEqual (new Rectangle (1, 2, 96, 94), c.DisplayRectangle);
+			}
+		}
+
+		[Test]
+		public void DockPadding()
+		{
+			using (var c = new ScrollableControl ())
+			{
+				c.Padding = new Padding(4);
+				Assert.AreEqual (4, c.DockPadding.All);
+			}
+		}
 	}
 }
